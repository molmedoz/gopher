package runtime

import (
	"fmt"
	"os"
	"path/filepath"
	"runtime"
	"strings"
)

// setupEnvironment sets up environment variables for a specific Go version
func (m *Manager) setupEnvironment(version string) error {
	if !m.config.SetEnvironment {
		return nil
	}

	// Get environment variables from config
	envVars := m.config.GetEnvironmentVariables(version)

	// Create environment setup script
	scriptPath, err := m.createEnvironmentScript(version, envVars)
	if err != nil {
		return fmt.Errorf("failed to create environment script: %w", err)
	}

	// Display instructions to user
	fmt.Printf("✓ Environment variables configured for Go %s\n", version)
	fmt.Printf("  To activate this environment, run:\n")
	fmt.Printf("  source %s\n", scriptPath)
	fmt.Printf("  Or add the following to your shell profile:\n")
	for key, value := range envVars {
		fmt.Printf("  export %s=%s\n", key, value)
	}

	return nil
}

// setupSystemEnvironment sets up environment variables for system Go
func (m *Manager) setupSystemEnvironment() error {
	if !m.config.SetEnvironment {
		return nil
	}

	// Get system Go info
	systemDetector := NewSystemDetector()
	systemInfo, err := systemDetector.GetSystemGoInfo()
	if err != nil {
		return fmt.Errorf("failed to get system Go info: %w", err)
	}

	// Create environment variables for system Go
	envVars := make(map[string]string)
	envVars["GOROOT"] = systemInfo.GOROOT
	envVars["GOPATH"] = systemInfo.GOPATH
	envVars["PATH"] = filepath.Join(systemInfo.GOROOT, "bin") + string(os.PathListSeparator) + m.envProvider.Getenv("PATH")

	// Create environment setup script
	scriptPath, err := m.createEnvironmentScript("system", envVars)
	if err != nil {
		return fmt.Errorf("failed to create environment script: %w", err)
	}

	// Display instructions to user
	fmt.Printf("✓ Environment variables configured for system Go\n")
	fmt.Printf("  To activate this environment, run:\n")
	fmt.Printf("  source %s\n", scriptPath)

	return nil
}

// createEnvironmentScript creates a shell script to set up environment variables
func (m *Manager) createEnvironmentScript(version string, envVars map[string]string) (string, error) {
	// Create script directory
	scriptDir := filepath.Join(m.config.InstallDir, "..", "scripts")
	if err := os.MkdirAll(scriptDir, 0755); err != nil {
		return "", fmt.Errorf("failed to create script directory: %w", err)
	}

	// Create script file
	scriptName := fmt.Sprintf("go-%s.env", version)
	scriptPath := filepath.Join(scriptDir, scriptName)

	// Generate script content
	scriptContent := fmt.Sprintf("#!/bin/bash\n# Go %s environment setup\n# Generated by gopher\n\n", version)

	for key, value := range envVars {
		scriptContent += fmt.Sprintf("export %s=%s\n", key, value)
	}

	scriptContent += fmt.Sprintf("\n# Go version: %s\n", version)
	scriptContent += "echo \"Go environment activated for version: " + version + "\"\n"

	// Write script file
	if err := os.WriteFile(scriptPath, []byte(scriptContent), 0755); err != nil {
		return "", fmt.Errorf("failed to write environment script: %w", err)
	}

	return scriptPath, nil
}

// saveActiveVersion saves the currently active version to a state file
func (m *Manager) saveActiveVersion(version string) error {
	stateDir := filepath.Join(m.config.InstallDir, "..", "state")
	if err := os.MkdirAll(stateDir, 0755); err != nil {
		return fmt.Errorf("failed to create state directory: %w", err)
	}

	stateFile := filepath.Join(stateDir, "active-version")
	content := fmt.Sprintf("active_version=%s\n", version)

	if err := os.WriteFile(stateFile, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write state file: %w", err)
	}

	return nil
}

// getActiveVersionFromState retrieves the active version from the state file
func (m *Manager) getActiveVersionFromState() (string, error) {
	stateFile := filepath.Join(m.config.InstallDir, "..", "state", "active-version")

	content, err := os.ReadFile(stateFile)
	if err != nil {
		return "", err
	}

	// Parse the content to extract the version
	lines := strings.Split(string(content), "\n")
	for _, line := range lines {
		if strings.HasPrefix(line, "active_version=") {
			return strings.TrimPrefix(line, "active_version="), nil
		}
	}

	return "", fmt.Errorf("active version not found in state file")
}

// setupShellIntegration sets up shell integration for persistent Go version switching
func (m *Manager) setupShellIntegration() error {
	// Detect the shell
	shell := m.detectShell()
	if shell == "" {
		return fmt.Errorf("unable to detect shell")
	}

	// Get shell profile path
	profilePath, err := m.getShellProfile(shell)
	if err != nil {
		return fmt.Errorf("failed to get shell profile: %w", err)
	}

	// Create gopher init script
	initScript, err := m.createGopherInitScript()
	if err != nil {
		return fmt.Errorf("failed to create gopher init script: %w", err)
	}

	// Add to shell profile
	if err := m.addToShellProfile(profilePath, initScript); err != nil {
		return fmt.Errorf("failed to add to shell profile: %w", err)
	}

	fmt.Printf("✓ Shell integration configured for %s\n", shell)
	fmt.Printf("  Restart your terminal or run: source %s\n", profilePath)

	return nil
}

// createGopherInitScript creates the gopher initialization script
func (m *Manager) createGopherInitScript() (string, error) {
	// Create scripts directory
	scriptsDir := filepath.Join(m.config.InstallDir, "..", "scripts")
	if err := os.MkdirAll(scriptsDir, 0755); err != nil {
		return "", fmt.Errorf("failed to create scripts directory: %w", err)
	}

	// Create gopher init script
	initScriptPath := filepath.Join(scriptsDir, "gopher-init.sh")

	// Generate script content
	scriptContent := `#!/bin/bash
# Gopher shell integration
# This script is automatically generated by gopher

# Function to get the active Go version
gopher_get_active_version() {
    local state_file="$HOME/.gopher/state/active-version"
    if [ -f "$state_file" ]; then
        local active_version=$(grep "active_version=" "$state_file" | cut -d'=' -f2)
        if [ -n "$active_version" ]; then
            echo "$active_version"
            return 0
        fi
    fi
    return 1
}

# Function to setup Go environment
gopher_setup_environment() {
    local version="$1"
    
    if [ "$version" = "system" ]; then
        # Use system Go
        unset GOROOT
        export GOPATH="$HOME/go"
        return 0
    fi
    
    # Set up gopher-managed Go version
    local gopher_dir="$HOME/.gopher"
    local version_dir="$gopher_dir/versions/$version"
    
    if [ -d "$version_dir" ]; then
        export GOROOT="$version_dir"
        export GOPATH="$HOME/go"
        export PATH="$version_dir/bin:$PATH"
    fi
}

# Auto-setup Go environment on shell startup
if command -v gopher >/dev/null 2>&1; then
    local active_version
    if active_version=$(gopher_get_active_version 2>/dev/null); then
        gopher_setup_environment "$active_version"
    fi
fi

# Gopher command aliases
alias gopher-list="gopher list"
alias gopher-use="gopher use"
alias gopher-install="gopher install"
alias gopher-uninstall="gopher uninstall"
alias gopher-current="gopher current"
alias gopher-system="gopher system"
`

	// Write script file
	if err := os.WriteFile(initScriptPath, []byte(scriptContent), 0755); err != nil {
		return "", fmt.Errorf("failed to write gopher init script: %w", err)
	}

	return initScriptPath, nil
}

// detectShell detects the current shell
func (m *Manager) detectShell() string {
	// Check SHELL environment variable
	if shell := m.envProvider.Getenv("SHELL"); shell != "" {
		return m.detectShellFromPath(shell)
	}

	// Check common shell paths
	commonShells := []string{
		"/bin/bash",
		"/bin/zsh",
		"/bin/sh",
		"/usr/bin/bash",
		"/usr/bin/zsh",
		"/usr/bin/sh",
	}

	for _, shellPath := range commonShells {
		if _, err := os.Stat(shellPath); err == nil {
			return m.detectShellFromPath(shellPath)
		}
	}

	return ""
}

// detectShellFromPath detects shell type from path
func (m *Manager) detectShellFromPath(shellPath string) string {
	shellName := filepath.Base(shellPath)

	switch shellName {
	case "bash":
		return "bash"
	case "zsh":
		return "zsh"
	case "sh":
		return "sh"
	case "fish":
		return "fish"
	default:
		return shellName
	}
}

// getShellProfile gets the shell profile file path
func (m *Manager) getShellProfile(shell string) (string, error) {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return "", fmt.Errorf("failed to get home directory: %w", err)
	}

	switch shell {
	case "bash":
		// Check for .bash_profile first, then .bashrc
		if _, err := os.Stat(filepath.Join(homeDir, ".bash_profile")); err == nil {
			return filepath.Join(homeDir, ".bash_profile"), nil
		}
		return filepath.Join(homeDir, ".bashrc"), nil
	case "zsh":
		return filepath.Join(homeDir, ".zshrc"), nil
	case "sh":
		return filepath.Join(homeDir, ".profile"), nil
	case "fish":
		return filepath.Join(homeDir, ".config", "fish", "config.fish"), nil
	default:
		return filepath.Join(homeDir, ".profile"), nil
	}
}

// addToShellProfile adds gopher initialization to shell profile
func (m *Manager) addToShellProfile(profilePath, initScript string) error {
	// Check if already added
	content, err := os.ReadFile(profilePath)
	if err != nil {
		// If file doesn't exist, create it
		content = []byte{}
	}

	// Check if gopher init is already in the profile
	if strings.Contains(string(content), "gopher-init.sh") {
		return nil // Already added
	}

	// Add gopher initialization
	addition := fmt.Sprintf(`
# Gopher shell integration
if [ -f "%s" ]; then
    source "%s"
fi
`, initScript, initScript)

	// Append to profile
	newContent := string(content) + addition
	return os.WriteFile(profilePath, []byte(newContent), 0644)
}

// createSymlink creates a symlink to the go binary
func (m *Manager) createSymlink(binaryPath string) error {
	// Use a consistent symlink location for all versions
	// This allows switching versions by just updating the symlink target
	symlinkPath, err := m.getGopherSymlinkPath()
	if err != nil {
		return fmt.Errorf("failed to get gopher symlink path: %w", err)
	}

	// Create or update the symlink
	if err := m.tryCreateSymlink(binaryPath, symlinkPath); err != nil {
		return fmt.Errorf("failed to create symlink: %w", err)
	}

	symlinkDir := filepath.Dir(symlinkPath)
	fmt.Printf("✓ Created symlink in %s\n", symlinkPath)
	fmt.Printf("  Add %s to your PATH to use this Go version\n", symlinkDir)

	// Check if the directory is already in PATH
	if !m.isDirectoryInPath(symlinkDir) {
		fmt.Printf("  ⚠️  Directory not in PATH - you may need to restart your terminal\n")
		fmt.Printf("  Or run: export PATH=\"%s:$PATH\"\n", symlinkDir)
		if runtime.GOOS == "windows" {
			fmt.Printf("  Windows: Add %s to your PATH environment variable\n", symlinkDir)
		}
	} else {
		fmt.Printf("  ✓ Directory is in PATH\n")
	}

	return nil
}

// tryCreateSymlink attempts to create a symlink
func (m *Manager) tryCreateSymlink(binaryPath, symlinkPath string) error {
	// Remove existing symlink if it exists
	if _, err := os.Lstat(symlinkPath); err == nil {
		if err := os.Remove(symlinkPath); err != nil {
			return fmt.Errorf("failed to remove existing symlink: %w", err)
		}
	}

	// Create the symlink
	return os.Symlink(binaryPath, symlinkPath)
}

// isSymlinkActuallyUsed checks if a symlink is actually being used
func (m *Manager) isSymlinkActuallyUsed(symlinkPath string) bool {
	// Check if the symlink exists
	fileInfo, err := os.Lstat(symlinkPath)
	if err != nil {
		return false
	}

	// Check if it's actually a symlink
	if fileInfo.Mode()&os.ModeSymlink == 0 {
		return false
	}

	// Check if the target exists
	if target, err := os.Readlink(symlinkPath); err == nil {
		if _, err := os.Stat(target); err == nil {
			return true
		}
	}

	return false
}

// hasGopherSymlinkInPath checks if there's a gopher symlink in PATH
func (m *Manager) hasGopherSymlinkInPath() bool {
	pathEnv := m.envProvider.Getenv("PATH")
	paths := strings.Split(pathEnv, string(os.PathListSeparator))

	for _, path := range paths {
		goPath := filepath.Join(path, "go")
		if runtime.GOOS == "windows" {
			goPath = filepath.Join(path, "go.exe")
		}

		if _, err := os.Lstat(goPath); err == nil {
			if target, err := os.Readlink(goPath); err == nil {
				if strings.Contains(target, "gopher") || strings.Contains(target, ".gopher") {
					return true
				}
			}
		}
	}

	return false
}

// isDirectoryInPath checks if a directory is in PATH
func (m *Manager) isDirectoryInPath(dir string) bool {
	pathEnv := m.envProvider.Getenv("PATH")
	paths := strings.Split(pathEnv, string(os.PathListSeparator))

	for _, path := range paths {
		if path == dir {
			return true
		}
	}

	return false
}

// addSymlinkToPath adds symlink directory to PATH for current session
func (m *Manager) addSymlinkToPath(binaryPath string) error {
	// Get the gopher symlink directory (not the binary directory)
	symlinkPath, err := m.getGopherSymlinkPath()
	if err != nil {
		return err
	}
	symlinkDir := filepath.Dir(symlinkPath)

	// Check if already in PATH
	if m.isDirectoryInPath(symlinkDir) {
		return nil
	}

	// Add to PATH for current session
	currentPath := m.envProvider.Getenv("PATH")
	newPath := symlinkDir + string(os.PathListSeparator) + currentPath
	return os.Setenv("PATH", newPath)
}

// removeGopherSymlinks removes all gopher-created symlinks
func (m *Manager) removeGopherSymlinks() error {
	pathEnv := m.envProvider.Getenv("PATH")
	paths := strings.Split(pathEnv, string(os.PathListSeparator))
	removedCount := 0

	for _, path := range paths {
		goPath := filepath.Join(path, "go")
		if runtime.GOOS == "windows" {
			goPath = filepath.Join(path, "go.exe")
		}

		if _, err := os.Lstat(goPath); err == nil {
			if target, err := os.Readlink(goPath); err == nil {
				if m.extractVersionFromPath(target) != "" {
					if err := os.Remove(goPath); err == nil {
						removedCount++
						fmt.Printf("  Removed symlink: %s\n", goPath)
					} else {
						fmt.Printf("  Warning: failed to remove symlink %s: %v\n", goPath, err)
					}
				}
			}
		}
	}

	if removedCount > 0 {
		fmt.Printf("✓ Removed %d gopher symlinks\n", removedCount)
	}

	return nil
}

// getGopherSymlinkPath returns the standard gopher symlink path
func (m *Manager) getGopherSymlinkPath() (string, error) {
	userHome, err := os.UserHomeDir()
	if err != nil {
		return "", fmt.Errorf("failed to get user home directory: %w", err)
	}

	var symlinkPath string
	switch runtime.GOOS {
	case "windows":
		localBinDir := filepath.Join(userHome, "AppData", "Local", "bin")
		if err := os.MkdirAll(localBinDir, 0755); err != nil {
			return "", fmt.Errorf("failed to create local bin directory: %w", err)
		}
		symlinkPath = filepath.Join(localBinDir, "go.exe")
	default:
		// Use ~/.local/bin/go as the standard gopher symlink location
		localBinDir := filepath.Join(userHome, ".local", "bin")
		if err := os.MkdirAll(localBinDir, 0755); err != nil {
			return "", fmt.Errorf("failed to create local bin directory: %w", err)
		}
		symlinkPath = filepath.Join(localBinDir, "go")
	}

	return symlinkPath, nil
}

// checkWindowsPathOrder checks if Gopher's bin directory is before system Go in PATH.
// This is critical on Windows because PATH order determines which Go is found first.
func (m *Manager) checkWindowsPathOrder() error {
	if runtime.GOOS != "windows" {
		return nil
	}

	// Get system Go path if it exists
	systemDetector := NewSystemDetector()
	if !systemDetector.IsSystemGoAvailable() {
		return nil // No system Go, no conflict
	}

	systemPath, err := systemDetector.GetSystemGoPath()
	if err != nil {
		return nil // Can't determine system path, skip check
	}

	systemGoDir := filepath.Dir(systemPath)

	// Get Gopher's symlink directory
	symlinkPath, err := m.getGopherSymlinkPath()
	if err != nil {
		return nil
	}
	gopherBinDir := filepath.Dir(symlinkPath)

	// Get PATH and check order
	pathEnv := m.envProvider.Getenv("PATH")
	paths := strings.Split(pathEnv, string(os.PathListSeparator))

	gopherIndex := -1
	systemIndex := -1

	for i, p := range paths {
		cleanPath := filepath.Clean(p)
		if strings.EqualFold(cleanPath, gopherBinDir) {
			gopherIndex = i
		}
		if strings.EqualFold(cleanPath, systemGoDir) {
			systemIndex = i
		}
	}

	// If system Go comes before Gopher in PATH, warn the user
	if systemIndex != -1 && gopherIndex != -1 && systemIndex < gopherIndex {
		return fmt.Errorf(`
⚠️  WARNING: System Go will take precedence over Gopher-managed versions!

PATH Order Issue:
  Position %d: %s (System Go) ← Found FIRST
  Position %d: %s (Gopher) ← Found SECOND

This means 'go version' will still show system Go, not the version you just switched to.

TO FIX - Run this PowerShell command as Administrator:

  $userPath = [Environment]::GetEnvironmentVariable("PATH", "User")
  $machinePath = [Environment]::GetEnvironmentVariable("PATH", "Machine")
  
  # Remove Gopher's bin from user PATH
  $userPath = ($userPath -split ';' | Where-Object { $_ -ne '%s' }) -join ';'
  
  # Add Gopher's bin at the BEGINNING of user PATH
  $newUserPath = '%s;' + $userPath
  [Environment]::SetEnvironmentVariable("PATH", $newUserPath, "User")
  
  # Restart your terminal for changes to take effect

OR manually reorder PATH in System Settings:
  1. Win+R → sysdm.cpl → Advanced → Environment Variables
  2. In "User variables", select PATH → Edit
  3. Move '%s' to the TOP of the list
  4. Click OK and restart terminal

After fixing, verify with: where go
  (Should show Gopher's symlink first)
`, systemIndex+1, systemGoDir, gopherIndex+1, gopherBinDir, gopherBinDir, gopherBinDir, gopherBinDir)
	}

	// Gopher comes first or system Go not found - all good!
	if gopherIndex != -1 && (systemIndex == -1 || gopherIndex < systemIndex) {
		fmt.Printf("✓ PATH order correct (Gopher before system Go)\n")
	}

	return nil
}
